# leetcode_python
Here's a 15-day plan to solve the "Must Do Easy" LeetCode problems. Each day focuses on different concepts, with 3 problems per day.

### Day 1: Strings Basics
- **Problem 1**: Reverse String
- **Problem 2**: Valid Palindrome
- **Problem 3**: Implement strStr()

**Concepts Required**:
- String manipulation
- Two-pointer technique
- Slicing

### **Day 2: Arrays Introduction**
- **Problem 1**: Remove Duplicates from Sorted Array
- **Problem 2**: Rotate Array
- **Problem 3**: Contains Duplicate

**Concepts Required**:
- Array traversal
- In-place modification
- Hash sets

### **Day 3: Hashing Fundamentals**
- **Problem 1**: Two Sum
- **Problem 2**: Intersection of Two Arrays
- **Problem 3**: Valid Anagram

**Concepts Required**:
- Hash maps/dictionaries
- Counting frequency of elements
- Sorting

### **Day 4: Linked List Basics**
- **Problem 1**: Merge Two Sorted Lists
- **Problem 2**: Linked List Cycle
- **Problem 3**: Remove Linked List Elements

**Concepts Required**:
- Singly linked list operations
- Pointers (head, next)
- Cycle detection

### **Day 5: Math and Bit Manipulation**
- **Problem 1**: Single Number
- **Problem 2**: Missing Number
- **Problem 3**: Power of Two

**Concepts Required**:
- Bit manipulation
- XOR operation
- Mathematical properties

### **Day 6: Stack Basics**
- **Problem 1**: Valid Parentheses
- **Problem 2**: Min Stack
- **Problem 3**: Implement Queue using Stacks

**Concepts Required**:
- Stack data structure
- LIFO (Last-In-First-Out) principle
- Two stacks approach

### **Day 7: Recursion and Backtracking**
- **Problem 1**: Climbing Stairs
- **Problem 2**: Pascal's Triangle
- **Problem 3**: Subsets

**Concepts Required**:
- Recursion basics
- Dynamic programming
- Backtracking

### **Day 8: Greedy Algorithms**
- **Problem 1**: Best Time to Buy and Sell Stock
- **Problem 2**: Maximum Subarray
- **Problem 3**: House Robber

**Concepts Required**:
- Greedy approach
- Dynamic programming for optimization
- Kadane's algorithm

### **Day 9: Tree Basics**
- **Problem 1**: Maximum Depth of Binary Tree
- **Problem 2**: Symmetric Tree
- **Problem 3**: Same Tree

**Concepts Required**:
- Binary tree traversal (DFS, BFS)
- Recursion
- Tree node structure

### **Day 10: Binary Search**
- **Problem 1**: Binary Search
- **Problem 2**: First Bad Version
- **Problem 3**: Search Insert Position

**Concepts Required**:
- Binary search algorithm
- Divide and conquer
- Edge cases in search problems

### **Day 11: Two Pointers**
- **Problem 1**: Move Zeroes
- **Problem 2**: Remove Element
- **Problem 3**: Squares of a Sorted Array

**Concepts Required**:
- Two-pointer technique
- Array manipulation
- In-place modifications

### **Day 12: Sliding Window**
- **Problem 1**: Minimum Size Subarray Sum
- **Problem 2**: Longest Substring Without Repeating Characters
- **Problem 3**: Permutation in String

**Concepts Required**:
- Sliding window technique
- Subarray problems
- Hash maps for frequency counting

### **Day 13: Advanced Array Manipulations**
- **Problem 1**: Plus One
- **Problem 2**: Merge Sorted Array
- **Problem 3**: Majority Element

**Concepts Required**:
- Array operations
- Merging techniques
- Counting algorithms

### **Day 14: Dynamic Programming**
- **Problem 1**: Fibonacci Number
- **Problem 2**: Maximum Product Subarray
- **Problem 3**: Coin Change

**Concepts Required**:
- Dynamic programming basics
- Memoization
- Tabulation

### **Day 15: Recap and Revision**
- **Problem 1**: Any problem you found challenging
- **Problem 2**: Another problem you found challenging
- **Problem 3**: Try solving a problem without looking at any references

**Concepts Required**:
- Review concepts learned
- Consolidate problem-solving skills
- Practice without hints

This plan systematically covers essential LeetCode problems, focusing on key concepts that are foundational for problem-solving in coding interviews. By the end of this plan, you'll have a solid understanding of the basics required to tackle easy-level problems on LeetCode.
